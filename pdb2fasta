#!/usr/bin/python

## Alex Holehouse
## Pappulab
## April 2014
##
## pdb2fasta
##
## Converts a PDB file 
##
##

VERSION=0.1

AADICT = {"ALA":"A", 
          "CYS":"C", 
          "ASP":"D", 
          "GLU":"E",
          "PHE":"F",
          "GLY":"G",
          "HIS":"H",
          "HID":"H",
          "HIE":"H",
          "ILE":"I",
          "LYS":"K",
          "LEU":"L",
          "MET":"M",
          "ASN":"N",
          "PRO":"P",
          "GLN":"Q",
          "ARG":"R",
          "SER":"S",
          "THR":"T",
          "VAL":"V",
          "TRP":"W",
          "TYR":"Y",
          "ACE":"+",
          "NAC":"-"}
          

def print_header():
    print "#############################################"
    print "#                PDB2FASTA                  #"
    print "#############################################"



def get_col_indices(collist):

    # Types of collumn setups
    # cols == 10
    #   COL=[ATOM]
    #   COL=[1]
    #   COL=[CH3]
    #   COL=[ACE]
    #   COL=[1]
    #   COL=[33.000]
    #   COL=[29.720]
    #   COL=[36.600]
    #   COL=[1.00]
    #   COL=[1.00]
    #
    # cols == 11
    #   COL=[ATOM]
    #   COL=[1]
    #   COL=[CH3]
    #   COL=[ACE]
    #   COL=[A] *****CHAIN******
    #   COL=[1]
    #   COL=[0.000]
    #   COL=[0.000]
    #   COL=[0.000]
    #   COL=[1.00]
    #   COL=[0.00]
    # cols == 12
    #   COL=[ATOM]
    #   COL=[1]
    #   COL=[N]
    #   COL=[LYS]
    #   COL=[A] *****CHAIN******
    #   COL=[1]
    #   COL=[35.365]
    #   COL=[22.342]
    #   COL=[-11.980]
    #   COL=[1.00]
    #   COL=[22.28]
    #   COL=[N] *******ATOM&&&&&&&


    sub=0

    for i in collist:
        if i == "\n" or i == "\t":
            sub=sub+1

    num_cols = len(collist)-sub
    
    if num_cols == 11 or num_cols == 12:
        return (5,4)
    if num_cols == 10:
        return (4,-1)

    print "Unexpected number of columns in PDB file - is this valid?"
    raise Exception
    


                        
           
def read_file(pdbfilename):                                                                                                                                                                                                        
    """ Reads a file into a content list line by line                                                                                                                                                                                    
    and returns that list
    """
    with open(pdbfilename) as f:
        content = f.readlines()

    return content

def three2one(aa):
    return AADICT[aa.upper()]
    

def read_residues(content):
    
    """ Function to read the content list and extract residues into
    a residue list. Note this uses lists and not dictionaries
    so if a PDB has multiple residues with the same number (but
    , for example, different chains) we don't overwrite residues.
    
    This the get_residue function is a search operation instead of
    a dictionary lookup, but builds in robustness and redunancy which
    is good! 
    """
        
    residues = []

    # scan through the content and pull residues
    # into a list
    allres = []
    temp_res =[]


    # determine number of columns being used\

    
    

    for line in content:
        if filter(None, line.split(" "))[0].upper() == "ATOM":
            atomline= filter(None, line.split(" "))
            
            (resid_num,chain_num) = get_col_indices(atomline)
            break
        
    first=True
    
    #print "cols is " + str(cols)

    for line in content:
        
        # if the current line is an atom...
        if filter(None, line.split(" "))[0].upper() == "ATOM":            

            # if this is the first time use this to define how the numbering works out
            
            if first:
                first=False
                current_res=int(filter(None, line.split(" "))[resid_num])
                temp_res.append(filter(None, line.split(" ")))
                continue
            

            # if the current atom comes a residue equal to the
            # current_res then append this atom to the temp_res
            # list (think of the temp_res list as a list which holds
            # each residue as it's built                                

            if current_res == int(filter(None, line.split(" "))[resid_num]):
                temp_res.append(filter(None, line.split(" ")))

                # If the current_res+1 is equal to the residue of the
                # line's atom we've 
            elif current_res+1 == int(filter(None, line.split(" "))[resid_num]):
                current_res=current_res+1                    
                if len(temp_res) > 0: 
                    allres.append(temp_res)
                    temp_res = []
                    temp_res.append(filter(None, line.split(" ")))                
                else:
                    print "ERROR"
                    raise Exception                

                
        if filter(None, line.split(" "))[0].upper().strip() == "TER":
            allres.append(temp_res)
            temp_res = []
            first=True
            

    return allres


## ===================================================================================================
##                              Main Script - hold onto your hat!
## ===================================================================================================

if __name__=="__main__":
    import argparse 
    import sys
    from numpy import std, mean

    parser = argparse.ArgumentParser()
    parser.add_argument("--file","-f", help="PDB file") 
    parser.add_argument("--chain","-c", help="Chain in PDB file (optional)") 
    parser.add_argument("--three","-t", help="Print three letter codes (optional)",action='store_true', default=False)
    parser.add_argument("--usage","-u", help="Print help and exit",action='store_true', default=False)
    parser.add_argument("--version","-v", help="Print version and exit",action='store_true', default=False)

    args = parser.parse_args()

    if args.usage:
        print_header()

        print " Usage:"
        print " pdb2fasta -f <pdb file> # print protein sequence from PDB file"
        print " pdb2fasta -c <pdb file> # print number and names of chains in file"
        print " pdb2fasta -f <pdb file> -c <chain> # print protein sequence from chain <chain> in PDB file"
        print " pdb2fasta -f <pdb file> [-c <chain>] -t # print three letter code instead of one letter code"
        print ""
        print " For additional help or bug reports see https://github.com/alexholehouse/pdb2fasta"
        print " Version " + str(VERSION)
        exit(0)

    if args.version:
        print " Version " + str(VERSION)
        exit(0)
        
    print_header()

    if args.file:
        filename=args.file        
    elif args.chain:
        print "In chain mode - counting number of chains"
        filename=args.chain
        content = read_file(filename)
        residues = read_residues(content)

        # determine the number of real columns in the "ATOMS" lines of the PDB file
        (resid_num,chain_num) = get_col_indices(residues[0][0])
        
        if chain_num == -1:
            print "Unable to get chain number from PDB file"
        
        chaincount=0
        chaincurrent="-"
        chainlist = []
        for i in residues:
            atom = i[0]
            if atom[chain_num] == chaincurrent:
                pass
            else:
                
                chaincount=chaincount+1
                chaincurrent=atom[chain_num]
                chainlist.append(chaincurrent)
        print "Number of chains: " + str(chaincount)
        print "Chains are: " + str(chainlist)
        exit(0)
            
            
    else:
        
        print "[FATAL ERROR]: Please provide a filename (-f 'filename')"
        exit(1)


    content = read_file(filename)

    residues = read_residues(content)

    (resid_num,chain_num) = get_col_indices(residues[0][0])
    resname_num = 3 # note this is always three irrespective of PDB type

    

    if args.chain:        

        if chain_num == -1:
            print "Unable to get chain number from PDB file"
    
        count=0
        for res in residues:
            atom = res[0]
            if atom[chain_num] == args.chain:
                
                if args.three:
                    if count%20 == 0:
                        print ""

                    sys.stdout.write(atom[resname_num])
                    sys.stdout.write(" ")
                else:
                    if count%50 == 0:
                        print ""
                    sys.stdout.write(three2one(atom[resname_num]))
                    if count%10 == 0 and not count%50 == 0 and not count == 0:
                        sys.stdout.write(" ")

                count=count+1

        print ""
    else:        

        count=0
        for res in residues:
            atom = res[0]

            if args.three:
                if count%20 == 0:
                    print ""

                sys.stdout.write(atom[resname_num])
                sys.stdout.write(" ")
            else:
                if count%50 == 0:
                    print ""

                sys.stdout.write(three2one(atom[resname_num]))
                if count%10 == 0 and not count%50 == 0 and not count == 0:
                    sys.stdout.write(" ")

            count=count+1
        print ""

  
